PHASE1_REBUILD

Phase 1 Overview & Freeze Policy

This document outlines the Phase 1 macro-level rebuild of the Seggs.Life members‚Äô area. It is a standalone plan (separate from any existing plan.md) and will override all previous plans for Windsurf AI until this rebuild is finished. During this phase, a strict feature freeze is in effect: no hotfixes, patches, or unrelated feature work may be done until Phase 1 is completed and approved. The focus is solely on the comprehensive page-by-page rebuild detailed below. All development must prioritize user-specific data integration (gender, identity, spiciness, blueprint, partner status) loaded from Firestore (UserMemory) ‚Äì this state is the single source of truth and should only be changed via the Settings page. The rebuild will proceed in structured steps with clear checkpoints, and no quick-fix shortcuts are allowed until the entire members‚Äô area rebuild is signed off.

Page-by-Page Rebuild Plan (Members‚Äô Area)

Each of the following sub-sections corresponds to a page under /src/app/(main). For each page, the required UI components, state integration points, AI service needs, and a commit checkpoint are specified. All pages must be rebuilt or refactored to use the centralized user state (UserMemory) for personalization. After completing each page module, commit the changes following the specified commit message format (see GitOps guidelines below).

/boudoir
	‚Ä¢	Required Components: An AI-driven TopicCarousel component (new) that displays a scrollable list of intimate topic prompts generated for the user. Include a SpicinessSlider (new or reused) to adjust content ‚Äúspiciness‚Äù level (explicitness) in real-time. A section for a blueprint-personalized prompt preview should show how the suggestions adapt based on the user‚Äôs Erotic Blueprint (e.g. highlight or tag prompts relevant to the user‚Äôs blueprint type). UI controls for cycling topics (next/previous) and any preview of the full prompt text should be present.
	‚Ä¢	State Integration: Pull the user‚Äôs current spiciness preference and Erotic Blueprint data from UserMemory on render to tailor the initial carousel content. The spiciness slider‚Äôs default value should reflect the user‚Äôs saved preference, and changing it filters/regenerates topics accordingly. The user‚Äôs blueprint type (or scores) informs which topics are shown or emphasized (e.g. if the user‚Äôs blueprint is Sensual, the carousel might prioritize sensual-oriented prompts). Ensure any changes (like spiciness adjustments) do not permanently overwrite state except via Settings (i.e. the slider here is ephemeral unless saved in Settings).
	‚Ä¢	AI Service Dependencies: Integrate with the AI service (via aiService.ts or similar) to fetch/generate topic suggestions. The service call should include parameters for the user‚Äôs blueprint profile and desired spiciness level, so that returned topics are personalized. This likely requires a new API endpoint or function, e.g. getBoudoirTopics(blueprintProfile, spicinessLevel), which returns a list of prompt ideas. Ensure the AI prompt template for this service uses the user‚Äôs gender/identity (for context or pronouns) and blueprint info to yield relevant content. No image or multimedia is needed here ‚Äì text prompts only.
	‚Ä¢	Commit Checkpoint: After implementing and testing the Boudoir page and its components, commit the changes with message: ‚úÖ Phase1: Boudoir MVP complete.

/generator
	‚Ä¢	Required Components: A Flirty/Sexy Message Generator interface. This includes input controls for: Spiciness (reuse the slider component to set how explicit the message can be), Audience Type (e.g. a dropdown to select if the message is for their partner, for themselves, or other context ‚Äì likely ‚Äúpartner‚Äù vs ‚Äúself‚Äù or a custom name if partner linked), and Tone Selection (dropdown or buttons for tone, e.g. playful, romantic, dirty, witty, etc.). A Generate Button to submit the request. Below the form, display the generated text output in a scrollable text area or card, with a Copy-to-Clipboard button for convenience. Keep the UI text-only (no images), focusing on easy copy functionality.
	‚Ä¢	State Integration: Initialize the spiciness slider to the user‚Äôs default spiciness from UserMemory. If the user has a partner linked, pre-select the audience type to ‚ÄúPartner‚Äù (and possibly display the partner‚Äôs name if available) ‚Äì otherwise default to a self-oriented or generic option. The user‚Äôs gender and identity should be implicitly considered (for example, if the user is male and identifies as such, the tone or output might use certain pronouns; ensure these details are available to the AI prompt but the form can remain simple). The generator page itself doesn‚Äôt permanently change user state; it just reads the preferences. Any changes to default spiciness or other profile info should be done in Settings only.
	‚Ä¢	AI Service Dependencies: Hook up the generator form to an AI text generation service. likely via an aiService method such as generateFlirtyMessage(audience, tone, spiciness, userProfile). This call should send the necessary context: the user‚Äôs blueprint info (to personalize content if relevant), their gender/identity (for pronoun and perspective accuracy), the selected tone and spiciness level, and whether the message is intended for a partner or self. The AI will return a flirtatious or sexy message text, which we then display. Ensure the AI prompt used is crafted to produce tasteful output aligned with the spiciness setting (and comply with any content guidelines). No images or voice ‚Äì text only. Implement a copy-to-clipboard function for the result.
	‚Ä¢	Commit Checkpoint: After building the Generator page and confirming it produces output correctly, commit with message: ‚úÖ Phase1: Generator MVP complete.

/dashboard
	‚Ä¢	Required Components: A Personal Dashboard showing an overview of the user‚Äôs intimate profile and quick-access features. Key sections on this page:
	‚Ä¢	Blueprint Summary Card: A component (new) that displays a summary of the user‚Äôs Erotic Blueprint results (e.g. primary blueprint type or a bar chart of all blueprint percentages). This could be a simple card with a title like ‚ÄúYour Erotic Blueprint‚Äù and a one-line summary or icon of the dominant type, plus maybe a prompt to view details (link to /blueprint page for full breakdown).
	‚Ä¢	Partner Link Status: Indicate whether the user has a partner connected. If a partner is linked, show the partner‚Äôs name (or an alias) and possibly their presence status or last active time (if such data is available). If no partner is linked, show an Invite/Link Partner call-to-action. This can be a small panel or banner. (The actual linking process is handled in Settings, but the dashboard should display status and provide a shortcut button to Settings or a dedicated link flow).
	‚Ä¢	Mood Tracking Widget: A minimal component to log or display the user‚Äôs current mood or recent moods. For MVP, this can be a simple emoji or slider input representing how the user feels (e.g. libido or emotional mood) and possibly a log of the last entry. Include a quick way to record today‚Äôs mood (which would save to Firestore). If robust tracking is too complex for Phase1, at least provide a static UI element with a placeholder (e.g. ‚ÄúToday‚Äôs Mood: üòä (Happy)‚Äù or a button ‚ÄúLog Mood‚Äù) that can later be hooked up. This signals where mood tracking will live.
	‚Ä¢	Quick Launch Tiles: A set of icon buttons or tiles linking to key sections: e.g. Boudoir, Generator, Blueprint Quiz, Explore, etc. Each tile should have an icon and label. These provide one-click access to the main features for convenience. For example, a tile ‚Äúüí° Boudoir Ideas‚Äù navigating to /boudoir, ‚Äú‚úâÔ∏è Sexy Message‚Äù to /generator, ‚Äúüìù Your Blueprint‚Äù to /blueprint, ‚Äúüîó Invite Partner‚Äù (if no partner) or ‚Äú‚ù§Ô∏è Partner Connected‚Äù (if linked, possibly opening partner-related features), etc., and Settings as well.
	‚Ä¢	State Integration: On load, fetch all relevant user info from UserMemory to populate the dashboard. The blueprint summary uses the stored blueprint scores/types (and remains blank or a prompt if the user hasn‚Äôt completed the quiz yet). The partner status section uses the user‚Äôs partner linkage data (e.g. a partnerId or flag in their profile) ‚Äì ensure it reflects real-time status if possible (if using a listener to partner‚Äôs activity or a simple online/offline indicator, though real-time updates could be optional). The mood tracking displays the latest mood entry from Firestore if available; if none, it may prompt to enter one. Quick launch tiles should be rendered dynamically based on state when appropriate (for instance, if the user has not taken the blueprint quiz, the tile might highlight ‚ÄúTake Blueprint Quiz‚Äù instead of ‚ÄúView Blueprint‚Äù). All displayed data (blueprint, partner, mood) should update if the underlying UserMemory changes (for example, if the user links a partner mid-session or completes the quiz, the dashboard should refresh to show updated info). This likely means using state management or listeners on UserMemory updates.
	‚Ä¢	AI Service Dependencies: Primarily the dashboard is a static display of stored data, so it doesn‚Äôt directly call AI. One exception: if we implement any AI-driven insight (not required in MVP), e.g. a personalized greeting or tip of the day, that could call an AI service. This is not in scope for Phase1 unless trivial. Focus on integrating stored data. (Note: The SeggsyBot, if floating on all pages, might appear on the dashboard too, but that is handled in the SeggsyBot section.)
	‚Ä¢	Commit Checkpoint: Once the Dashboard page is implemented with all sections updating from user state, commit with: ‚úÖ Phase1: Dashboard MVP complete.

/blueprint
	‚Ä¢	Required Components: The Erotic Blueprint Quiz & Results interface. This route serves dual purposes: letting the user take the quiz (if not done yet) and view their results (if completed). Components needed:
	‚Ä¢	Blueprint Quiz Form: A multi-step form or interactive questionnaire for the Erotic Blueprint. This can be a series of questions (possibly multiple-choice or rating scales) that determine the user‚Äôs scores across the blueprint categories. If an existing quiz format or data set is available, implement it; otherwise create a simplified set of questions to approximate the blueprint outcome. Include UI for navigating the quiz (next/back through questions, and a submit at the end).
	‚Ä¢	Result Display: After completion, show the user‚Äôs blueprint breakdown ‚Äì e.g. a list or chart of the five blueprint types (Sensual, Sexual, Energetic, Kinky, Shapeshifter) with the user‚Äôs percentage or score in each, highlighting the primary type. Also provide descriptions for each category (could be static text explaining what it means if available). This result screen should be accessible on return visits to /blueprint if the quiz is already done.
	‚Ä¢	Partner‚Äôs Blueprint (or Prediction): If the user has a linked partner, incorporate a section to handle the partner‚Äôs blueprint. If the partner has also completed the quiz on their account, display their results alongside or in a summary (if permissions allow). If the partner has not taken it, provide a way for the user to ‚ÄúPredict Your Partner‚Äôs Blueprint‚Äù. This could be a secondary quiz or a simplified picker that the user fills out on behalf of their partner. (For MVP, it might be easiest to allow the user to retake the same quiz in a ‚Äúpartner mode‚Äù and store those answers separately as a prediction, or simply select the one blueprint type they think fits their partner best.) Clearly label this as a guess/prediction.
	‚Ä¢	Ensure the UI distinguishes between the user‚Äôs own results and any partner data. Also, include a prompt or link to invite the partner to take the quiz themselves (if not already done) ‚Äì possibly via the partner linking mechanism.
	‚Ä¢	State Integration: On component mount, check UserMemory for existing blueprint results. If the current user‚Äôs blueprint scores are already stored, skip directly to the results display (with an option to retake or review answers, if desired). If not present, show the quiz form. When the user completes the quiz, calculate their blueprint scores and immediately save this data to UserMemory (Firestore) under their profile (e.g. store each category‚Äôs score, and a timestamp of completion). Similarly, if the user completes a partner-prediction quiz, store the prediction in a way that can be retrieved later. If a partner is linked and that partner‚Äôs actual blueprint is available (which would be in the partner‚Äôs own user data), fetch it (this may involve a Firestore read of the partner‚Äôs user document if security rules permit or if a Cloud Function proxies it). The page should react to changes: e.g. if the user finishes the quiz (state goes from incomplete to complete) or if a partner link is established later and partner data becomes available. Use appropriate state management or listeners for these transitions.
	‚Ä¢	AI Service Dependencies: None required for calculating the blueprint results ‚Äì the quiz logic is deterministic. However, if desired, an AI could be used to generate personalized feedback or analysis of the results (e.g. suggestions on how to improve compatibility or further resources based on blueprint type). This is optional and not core to Phase1. Focus on implementing the quiz and result storage.
	‚Ä¢	Commit Checkpoint: After the Blueprint quiz and results page is functional (including partner prediction logic and data storage), commit with: ‚úÖ Phase1: Blueprint MVP complete.

/explore
	‚Ä¢	Required Components: An Explore Resources page listing external erotic wellness resources. For Phase1 MVP, this page can be very simple: a list of links to articles, websites, or books that users might find useful. Use a basic List or Card view for each resource, including a title, a short description or tagline, and an outbound link (which should open in a new tab). No need for images or complex categorization in this phase. A simple heading like ‚ÄúExplore Erotic Resources‚Äù and a vertical list of resource links will suffice. This page is mostly static content.
	‚Ä¢	State Integration: Minimal state usage here. The content is not personalized for now, so it doesn‚Äôt heavily rely on user data. However, you might later filter or customize resources based on identity or orientation ‚Äì keep that in mind for future. For MVP, just ensure if any user preference would obviously exclude a resource (for instance, if some resources are gender-specific and the user‚Äôs gender makes it irrelevant), you might hide those ‚Äì but only if such logic is trivial. Otherwise, it‚Äôs a static list for all users. The only state to consider is maybe the user‚Äôs spiciness setting if we want to omit very explicit resources when the user is low-spiciness; but since no affiliate or advanced logic yet, likely not needed.
	‚Ä¢	AI Service Dependencies: None ‚Äì this is a static informational page. (In the future, an AI might recommend resources based on user profile, but Phase1 will not include that.)
	‚Ä¢	Commit Checkpoint: Once the Explore page is added with a basic list of outbound links, commit with: ‚úÖ Phase1: Explore MVP complete.

/settings
	‚Ä¢	Required Components: A Settings & Profile page where users can configure their personal details and preferences. This page should provide control over:
	‚Ä¢	Gender Selection: Allow the user to set or update their gender (and possibly pronouns). This could be a dropdown (Male, Female, Non-binary, etc.) or a text field with preset options. Include an option for ‚ÄúPrefer not to say‚Äù or custom if needed, but at least the main categories.
	‚Ä¢	Identity/Sexual Orientation: Let the user define their sexual identity or orientation (e.g. Straight, Gay, Bisexual, Queer, etc.) or any other identity relevant to how the app tailors content. If ‚Äúidentity‚Äù in this context means something else (like a role or kink identity), include the appropriate control. Clarify what ‚Äúidentity‚Äù means in the app context and provide a field or options accordingly.
	‚Ä¢	Spiciness Level Setting: A control for the user‚Äôs overall content rating preference. This can reuse the SpicinessSlider in a settings context (with maybe a numeric or descriptive label, like 1 (Mild) to 5 (Wild)). Changes here should update the user‚Äôs default spiciness preference in Firestore. This setting governs the default tone of content across the app (Boudoir, Generator, etc.), so make it prominent.
	‚Ä¢	Partner Status & Linking: If the user is currently single (no partner linked), show an Invite Partner option. This could generate an invite link or code to send to their partner for linking accounts, or allow entering the partner‚Äôs email to send an invite. If a partner is already linked, display the partner‚Äôs info (name or email) and perhaps an option to Unlink (with a warning/confirmation). Also show the status (e.g. ‚ÄúPartner Connected‚Äù if mutual link is active). The UI should guide the user through linking if not done (for MVP, even a simple text + code system is fine: e.g. ‚ÄúShare this code with your partner to link: ABC123‚Äù and a field for entering a partner‚Äôs code).
	‚Ä¢	(Any other profile controls that exist, such as age, language, etc., can be included as needed, but the above are the primary ones for this rebuild.)
	‚Ä¢	State Integration & Rewiring: The Settings page should load the current values from UserMemory for each field on render (e.g., selected gender, saved identity, spiciness level, partner link status). Use form controls bound to these values. When the user makes changes and clicks ‚ÄúSave‚Äù (or as they change if auto-save is desired), update the Firestore user profile accordingly. Ensure writes go through the proper service or API (e.g. using a UserService.updateProfile() method if one exists). For partner linking: if there is an existing PartnerStatusService or similar logic (as hinted in the codebase), use it for creating/validating link invites and handling partner references in both users‚Äô profiles. If not, implement a simple linking flow: e.g., when user A generates an invite code, save it in a collection or in user A‚Äôs profile; when user B enters that code, set each user‚Äôs partnerId to the other‚Äôs ID (and clear the code). All such updates must reflect in UserMemory so that other pages (dashboard, boudoir, SeggsyBot, etc.) can know the partner is linked. After any save, the updated state should immediately reflect in the UI (you might use local state to mirror inputs and then on success update global state). Also ensure that changing gender or identity might affect AI prompts (for instance, if the user changes pronouns, the AI context should update ‚Äì the SeggsyBot context will handle this reactively).
	‚Ä¢	AI Service Dependencies: The Settings page itself doesn‚Äôt call AI, but by changing preferences here, it indirectly affects how AI features behave elsewhere. For example, if the user changes spiciness from mild to wild here, the next calls to content generation in Boudoir or Generator should use the new value. So test that such changes persist and propagate (this might involve reloading some cached user context or simply relying on pulling fresh from Firestore on each AI call, which is safer for consistency).
	‚Ä¢	Commit Checkpoint: After implementing the Settings page with all fields and ensuring data flows to/from Firestore properly (and partner linking flow if applicable), commit with: ‚úÖ Phase1: Settings MVP complete.

SeggsyBot Integration (AI Assistant)

The SeggsyBot is a context-aware, AI-driven assistant that should be integrated as part of the members‚Äô area experience. It will function as a persistent floating chat assistant available across relevant pages (potentially via an icon or chat bubble overlay on all main pages like Dashboard, Boudoir, etc.). The SeggsyBot‚Äôs behavior and responses must dynamically adapt to the user‚Äôs state and changes therein.
	‚Ä¢	Context & State Inputs: Configure SeggsyBot to always receive the full spectrum of user context from UserMemory. This includes:
	‚Ä¢	User Profile: Gender and identity (so the bot uses correct pronouns and appropriate perspective), and any relevant preferences.
	‚Ä¢	Spiciness Preference: The user‚Äôs current content intensity setting, to ensure the bot‚Äôs tone and explicitness match the user‚Äôs comfort level. If the user adjusts spiciness in Settings (or temporarily in a feature), the bot should respect the new setting immediately for future replies.
	‚Ä¢	Erotic Blueprint Data: The user‚Äôs blueprint results (and possibly a brief summary of what that means about their preferences). The bot can use this to personalize its advice or responses ‚Äì e.g., if the user is ‚ÄúEnergetic‚Äù type, the bot might tailor suggestions to that style.
	‚Ä¢	Partner Connection Status: Whether the user has a linked partner and any partner-specific info available. If a partner is linked, the bot might provide guidance for couples (using ‚Äúwe‚Äù or suggesting partner-inclusive ideas). If no partner, it will focus on self or dating contexts. If a partner‚Äôs blueprint (actual or predicted) is available, feed that in as well so the bot can, for example, comment on compatibility or give tips that consider both partners‚Äô types.
	‚Ä¢	Reactive Adaptation: The SeggsyBot should listen for changes in the above state and update its context promptly. For instance, if a user completes the blueprint quiz mid-session, the bot‚Äôs next response should recognize that it now knows the user‚Äôs blueprint. If the user links a partner, the bot can acknowledge the new connection or shift to offering couples-oriented content. Implement this by either regenerating the bot‚Äôs conversation context on state changes or by structuring the bot‚Äôs prompts to always reference the latest state from a central store.
	‚Ä¢	UI/UX Implementation: Make the bot accessible but unobtrusive. For example, a circular chat icon that toggles the assistant, present on all main screens (perhaps in a corner as a floating element). Tapping it opens a chat window where the user can type questions or get tips. The bot‚Äôs chat interface can reuse an existing chat component if one exists (e.g., if there was a prior implementation of a chat). Ensure the component is part of the main layout so it persists across pages (likely added in a top-level layout or provider). The assistant should operate in real-time using an AI backend ‚Äì possibly the same aiService with a dedicated prompt structure that includes the user‚Äôs context. Keep conversation history short or relevant to avoid context overflow, focusing on the current session‚Äôs queries.
	‚Ä¢	AI Service Dependencies: Leverage the AI service to generate the assistant‚Äôs responses. This will likely involve a specific method like getAssistantResponse(userContext, userMessage) that sends a system prompt containing all the user‚Äôs context (blueprint summary, etc.) plus the conversation so far and the latest user query. The quality of this prompt is crucial for personalization. For MVP, a basic prompt like ‚ÄúYou are SeggsyBot, an AI sex-positive assistant. The user is [gender/identity], with [blueprint] blueprint, spiciness setting [level], [partner status]. Provide helpful, respectful advice or answers.‚Äù would be prepended to each interaction. Fine-tune as needed. This integration must also respect any rate limits or API keys (if using an external AI like OpenAI).
	‚Ä¢	Testing: Thoroughly test that the SeggsyBot indeed reflects changes: e.g., change spiciness in Settings and then ask the bot something to ensure the tone shifted; link a partner (or simulate it) and see if the bot starts referencing ‚Äúyour partner‚Äù in suggestions. The bot should never reveal anything beyond what the user‚Äôs state provides (all context is from the user‚Äôs own data).
	‚Ä¢	Commit Checkpoint: After fully integrating the SeggsyBot (with context wiring and UI) and verifying its reactivity, commit with message: ‚úÖ Phase1: SeggsyBot integration complete.

Archiving Legacy Components (No Deletions in Phase1)

As we implement this new members‚Äô area, some existing components or pages from the old system will become obsolete or need replacement. Do NOT delete any old code during Phase 1. Instead, archive it to preserve history and allow reference if needed:
	‚Ä¢	Identify all components, pages, or utilities that are no longer used or needed after the rebuild. This might include older versions of the pages (e.g. an old Boudoir or Dashboard component), deprecated helper functions, or any quick-fix code that is superseded by the new implementations.
	‚Ä¢	For each such file or component, add an inline comment at the top like // @archive Phase1 explaining that it‚Äôs been archived in Phase1 rebuild. Alternatively, move these files into a new directory named /__archive__/ within the project (maintaining structure if needed). For example, if OldDashboard.tsx is replaced, move it to __archive__/OldDashboard.tsx.
	‚Ä¢	Ensure that archived components are disconnected from the app so they don‚Äôt accidentally execute or interfere. That means updating imports or routes to point to the new components instead. After rerouting, you can safely archive the old files.
	‚Ä¢	By archiving rather than deleting, we maintain the ability to recover or reference removed features during development. This is crucial in Phase 1 in case we need to rollback any idea. Final removal can be done in a later phase after everything is confirmed stable.
	‚Ä¢	Double-check that nothing critical is lost: e.g., if the old plan.md or documentation exists in the repo, you may archive it as well since this PHASE1_REBUILD.md replaces it for now.
	‚Ä¢	No code deletion policy remains until Phase 1 completion. Archive anything not needed, but keep it version-controlled.

UserMemory as Single Source of Truth (State Preloading)

All features in this rebuild must derive their data from the central user state stored in Firestore (the UserMemory document/collection for the user). We treat this as the single source of truth for personalization. Key guidelines:
	‚Ä¢	Preload User Preferences: On app startup or upon user login, load the user‚Äôs profile data from Firestore exactly once (or keep a listener for changes). This includes gender, identity, spiciness preference, completed blueprint results, partner link info, mood entries, etc. This data should populate a global state (via context, Redux, or a dedicated service like UserService/UserMemory) that all pages/components can access.
	‚Ä¢	No Hard-Coding or Divergent State: Pages should not use hard-coded defaults that diverge from what‚Äôs in Firestore. For example, if a user‚Äôs spiciness is stored as 3 (Medium) in Firestore, every part of the app should reflect that unless the user actively changes it. The Settings page is the only place to intentionally override these values (which then writes back to Firestore and updates the global state).
	‚Ä¢	Real-Time Updates: When the user updates something in Settings (or when certain actions occur, like completing the blueprint quiz or linking a partner), update the Firestore data and let the change flow downstream. Use state management such that all components listening to that data update automatically. For instance, if UserMemory.spiciness changes, the Boudoir and Generator pages should use the new value on next render or next AI call. If UserMemory.partnerId changes (partner linked), the Dashboard and SeggsyBot should immediately reflect the presence of a partner.
	‚Ä¢	Consistency Across Screens: Ensure that if the user‚Äôs state is incomplete (say they haven‚Äôt set an identity or finished the quiz), all pages handle that gracefully and prompt the user consistently. All work (AI prompts, content, UI messages) should reference the centralized state so the user gets a cohesive experience. This avoids scenarios like one page thinking the user is single while another knows a partner is linked ‚Äì everything reads from the same truth.
	‚Ä¢	Firestore Structure: (Note for implementation) The Firestore data model should have fields for each of these user attributes. If any are missing (e.g., if previously spiciness or blueprint were not stored), update the data model to include them. This might involve migrations or simply defaulting to safe values if null (e.g., spiciness default medium, identity default blank, etc.). Always handle null/undefined in the UI by prompting the user to update their profile.

By adhering to this, the Phase 1 rebuild will produce a much more personalized and reliable experience, as all features ‚Äúspeak the same language‚Äù about the user‚Äôs profile.

GitOps Commit Guidelines

To maintain clarity and facilitate easier code reviews or rollbacks, follow these Git commit practices throughout Phase 1:
	‚Ä¢	Commit after each major module or page completion: As outlined, after finishing each page‚Äôs implementation (Boudoir, Generator, Dashboard, Blueprint, Explore, Settings) and after integrating global features like SeggsyBot or any other major service wiring, create a commit. This ensures that each feature can be tested in isolation and bisected if needed.
	‚Ä¢	Use Conventional Messages: Use the format ‚úÖ Phase1: <Feature> complete for commit messages. For example:
	‚Ä¢	‚úÖ Phase1: Boudoir MVP complete
	‚Ä¢	‚úÖ Phase1: Generator MVP complete
	‚Ä¢	‚Ä¶and so on for Dashboard, Blueprint, Explore, Settings.
	‚Ä¢	For the SeggsyBot integration or other cross-cutting steps, use ‚úÖ Phase1: SeggsyBot integration complete (or similar descriptor).
	‚Ä¢	Granularity: Do not lump multiple page implementations into one commit. Even if some pages are small, commit them separately. Commits should reflect the completion of the itemized tasks in this plan. If a page involves both front-end and back-end changes, you can still commit them together as one cohesive feature commit.
	‚Ä¢	Checkpoint Tags (Optional): You may tag the repository at significant milestones (e.g., phase1-boudoir-done) for reference, but the commit history itself should be sufficient.
	‚Ä¢	Push and Sync: After each commit, push the changes to the remote repository (or the main branch if working directly there) to keep backups and allow for any CI/CD pipelines or previews to run. This frequent commit rhythm helps catch integration issues early.
	‚Ä¢	Message Tone: The ‚úÖ checkmark indicates a completed checkpoint, which makes it easy to scan the commit log for Phase1 progress. Stick to the exact phrasing for consistency.
	‚Ä¢	Before merging or deploying Phase 1 changes (once everything is complete), ensure all intermediate commits are present. A final review can be done, but do not squash these commits on merge; preserving them is useful for historical reference during this locked phase.

Phase 1 Lockdown & Completion

This Phase 1 rebuild is a locked-phase development period. Until all the above modules are built, tested, and approved:
	‚Ä¢	No other bug fixes or feature additions should be done. If critical bugs arise, log them for fixing after Phase 1 or address them within this rebuild if they are inherently resolved by the new implementations.
	‚Ä¢	Similarly, do not introduce any new features or scope changes. Stick strictly to the plan. Any tempting ‚Äúquick improvement‚Äù must be deferred. This ensures development remains focused and the resulting system is coherent.
	‚Ä¢	Once every item in this PHASE1_REBUILD plan is completed and verified, we will do a comprehensive review. Only after sign-off should you consider leaving the locked phase. At that point (Phase 1 completion), normal development (including hotfixes or minor enhancements) can resume or Phase 2 can begin, as appropriate.
	‚Ä¢	Document the completion of Phase 1 (perhaps by creating a PHASE1_COMPLETE.md summary or updating status files) as per project convention. This signifies the freeze can be lifted.
	‚Ä¢	Until then, treat this document as the single guiding blueprint. All work must flow from it, and nothing external should derail this roadmap. The success of the rebuild depends on disciplined adherence to these specifications.

Focus on executing this plan step by step. With each commit and module completed, we move closer to a robust, personalized members‚Äô area. No patches or detours; Phase 1 ends only when the members‚Äô area is fully rebuilt and integrated as described, at which point we will have a much stronger foundation for any future enhancements. Stay on target, and good luck with the rebuild!